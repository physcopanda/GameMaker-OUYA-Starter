<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>-1</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// APPLICATION DISPLAY SETUP
// tell GMS how we want to draw the screen
// precalc as much as possible to save cycles in the step/draw loops
//

// frame rate calulations
time = get_timer(); // current time - used?
fps_str = "";       // frames per second
fps_old = fps_real; // current fps value

// surface for screen upscale
surf = -1;

// full screen dims
fsw = display_get_width();
fsh = display_get_height();

// actual window size (includes window itself!)
// this is initialised to zero as it forces a size change in the step event
wgw = 0;
wgh = 0;

// get the biggest fit scale for fullscreen allows clipping of the overscan incase we're close and
// wont loose to much screen at a bigger scale else we get HUGE unnecessary borders
fs_scale = min(floor(fsw / (global.ww - OVERSCANXY)), floor(fsh / (global.hh - OVERSCANXY)));

// initial full screen value - forced for android
fs = global.vdu_scale==0 || os_type == os_android;

// get current scale
if(fs){
    scale = fs_scale;         // fullscreen scale
} else {
    scale = global.vdu_scale; // windowed scale
}

// at this scale we render to this wwidth and hheight
ww = global.ww * scale;
hh = global.hh * scale;

// top left of rendered screen to center letterbox nicely
x = max(0, (fsw - ww)&gt;&gt;1);
y = max(0, (fsh - hh)&gt;&gt;1);

// get the horizontal and vertical texture scale factors
// this is refreshed at runtime as its the only time you
// can query it live
hs = 1;
vs = 1;

// handle vsync and windowing
if(os_type != os_android){    
    // VSync? May be only needed for WINDOWS?
    if(0 != global.vdu_vsync){
        display_reset(0, true);
        show_debug_message("vsync on");
    } else {
        display_reset(0, false);
        show_debug_message("vsync off");
    }
    // set fullscreen
    window_set_fullscreen(fs);
    
    // set the window to suit size if not fullscreen
    if(!fs){
        window_set_size(ww, hh);
    }   
}

// manually handle the draw process
application_surface_draw_enable(false);

// text anchor points to clip a rectangle out from
// we cut in at the shake_max position so we never
// see any blank space during shake
// it does add a black border the size of shake_max
tx1 = global.shake_max / global.ww;
tx2 = 1 - global.shake_max / global.ww;
ty1 = global.shake_max / global.hh;
ty2 = 1 - global.shake_max / global.hh;


</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// handle screen step
// shake
if(global.shaking){
    global.surfx = irandom_range(-global.shake_max, global.shake_max);
    global.surfy = irandom_range(-global.shake_max, global.shake_max);
} else {
    global.surfx = 0;
    global.surfy = 0;
}

// resize only for WINDOWS and MACINTOSH
if(os_type != os_android){
    // new fullscreen value?
    var fs_changed = window_get_fullscreen() != fs;
    // check resized - only if not fullscreen or full screen switching
    var win_size_changed = false;
    if(!fs){
        win_size_changed = window_get_width() != wgw || window_get_height() != wgh;
    }
    // if fullscreen changed
    if(fs_changed){
        // launch full screen
        if(window_get_fullscreen()){
            //show_debug_message("enter fullscreen");
            
            // update render variables
            ww = global.ww * fs_scale;
            hh = global.hh * fs_scale;
            // setup x and y
            x = (fsw - ww)&gt;&gt;1;
            y = (fsh - hh)&gt;&gt;1;
            //show_debug_message("drawn at " + string(fs_scale) + " scale");
            //show_debug_message("location " + string(x) + ", " + string(y));
            //show_debug_message("drawn screen size is " + string(ww) + " x " + string(hh));
            //show_debug_message("fullscreen size is " + string(fsw) + " x " + string(fsh));
        } else {
            // leave full screen
            //show_debug_message("exit fullscreen");
            // update render variables
            ww = global.ww * scale;
            hh = global.hh * scale;
            window_set_size(ww, hh);
            x = 0;
            y = 0;
            //show_debug_message("drawn at " + string(scale) + " scale");
        }
    } else if(win_size_changed){
        // not full screen and size changed
        ww = window_get_width();
        hh = window_get_height();
        // get window size
        //show_debug_message("size is " + string(ww) + " x " + string(hh));
        // adapt to fit nearest size
        scale = max(1, min(round(ww / global.ww), round(hh / global.hh)));
        
        // update render variables
        ww = global.ww*scale;
        hh = global.hh*scale;
        // if size is bigger than fs get next one down
        if(ww &gt; fsw || hh &gt; fsh){
            scale--;
            ww = global.ww*scale;
            hh = global.hh*scale;
        }
        window_set_size(ww, hh);
        x = 0;
        y = 0;
        // update the current window size
        wgw = window_get_width();
        wgh = window_get_height();
        
        //show_debug_message("drawn at " + string(scale) + " scale");
    }
    fs = window_get_fullscreen();
}

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// calculate fps every 0.5 second
if(get_timer() - time &gt; 500000){
    time = get_timer();
    show_debug_message("fps_real = " + string(fps_str));
}
fps_str = mean(fps_old, fps_real);
fps_old = fps_real;

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="64">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// DRAW THE DISPLAY

// NEVER ever ever ever interpolate!
texture_set_interpolation(false);
// get the draw scale
// scale for fullscreen is ignored
// this is deliberate so when we exit fullscreen
// we can return to the previous scale
var ds = scale;
// get the horizontal and vertical texture scale factors
var tex = surface_get_texture(application_surface);
hs = texture_get_width(tex);
vs = texture_get_height(tex);
if(fs){
    // full screen at max scale
    ds = fs_scale;
    d3d_set_projection_ortho(0, 0, fsw, fsh, 0);
    //show_debug_message("projection at full screen "+string(fsw)+"x"+string(fsh));
} else {
    d3d_set_projection_ortho(0, 0, ww, hh, 0);
    //show_debug_message("projection at window "+string(ww)+"x"+string(hh));
}

// texture offset due to shake
var txo = global.surfx / global.ww;
var tyo = global.surfy / global.hh;

// screen draw coords - clip a shake border
var sx1 = x + ds * global.shake_max;
var sy1 = y + ds * global.shake_max;
var sx2 = x + ww - (ds * global.shake_max);
var sy2 = y + hh - (ds * global.shake_max);
draw_set_colour(c_white);

draw_primitive_begin_texture(pr_trianglestrip, surface_get_texture(application_surface));
draw_vertex_texture(sx1, sy1, hs*(tx1+txo), vs*(ty1+tyo));
draw_vertex_texture(sx1, sy2, hs*(tx1+txo), vs*(ty2+tyo));
draw_vertex_texture(sx2, sy1, hs*(tx2+txo), vs*(ty1+tyo));
draw_vertex_texture(sx2, sy2, hs*(tx2+txo), vs*(ty2+tyo));
draw_primitive_end();
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// DEBUG OVERLAY
alpha = draw_get_alpha();

draw_set_alpha_test(false);
draw_enable_alphablend(true);

draw_set_alpha(0.75); // alpha is totally f00bared at the mo!
draw_set_font(global.font[0]);
draw_set_colour(c_black);

var text = "PROJECT " + PROJECT + " V" + GM_version + " build " + string(GM_build_date) + " fps = " + string(fps) + " fps real = " + string_format(fps_str, 4, 0) + " instances = " + string(instance_count) + " " + string(ww) + " x " + string(hh);
text += "#P1 " + string(global.p[1]) + " P2 " + string(global.p[2]) + " P3 " + string(global.p[3]) + " P4 " + string(global.p[4]);

for(var i=1; i&lt;=4; i++){
    if(global.p[i]!=GAMEPAD_NONE){
        text += "#FOUND [" + gamepad_get_description(global.p[i]) + "] on " + string(global.p[i]);
    }
}
var w = string_width(text);
var h = string_height(text);
draw_set_colour(c_white);
//draw_rectangle(x + 30, y + hh - 50, x + 34 + w, y + hh - 46 + h, false);
draw_rectangle(OVERSCANXY, OVERSCANXY, OVERSCANXY + 2 + w, OVERSCANXY + 2 + h, false);
draw_set_colour(c_black);
//draw_text(x + 32, y + hh - 48, text);
draw_text(OVERSCANXY, OVERSCANXY + 2, text);
draw_set_alpha(alpha);
//draw_enable_alphablend(false);
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
